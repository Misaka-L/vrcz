// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using Microsoft.Kiota.Abstractions;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Threading;
using System;
using VRCZ.VRChatApi.Generated.Auth.User.Favoritelimits;
using VRCZ.VRChatApi.Generated.Auth.User.Friends;
using VRCZ.VRChatApi.Generated.Auth.User.Notifications;
using VRCZ.VRChatApi.Generated.Auth.User.Playermoderations;
using VRCZ.VRChatApi.Generated.Auth.User.Subscription;
using VRCZ.VRChatApi.Generated.Auth.User.Unplayermoderate;
using VRCZ.VRChatApi.Generated.Models;
namespace VRCZ.VRChatApi.Generated.Auth.User
{
    /// <summary>
    /// Builds and executes requests for operations under \auth\user
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class UserRequestBuilder : BaseRequestBuilder
    {
        /// <summary>The favoritelimits property</summary>
        public global::VRCZ.VRChatApi.Generated.Auth.User.Favoritelimits.FavoritelimitsRequestBuilder Favoritelimits
        {
            get => new global::VRCZ.VRChatApi.Generated.Auth.User.Favoritelimits.FavoritelimitsRequestBuilder(PathParameters, RequestAdapter);
        }
        /// <summary>The friends property</summary>
        public global::VRCZ.VRChatApi.Generated.Auth.User.Friends.FriendsRequestBuilder Friends
        {
            get => new global::VRCZ.VRChatApi.Generated.Auth.User.Friends.FriendsRequestBuilder(PathParameters, RequestAdapter);
        }
        /// <summary>The notifications property</summary>
        public global::VRCZ.VRChatApi.Generated.Auth.User.Notifications.NotificationsRequestBuilder Notifications
        {
            get => new global::VRCZ.VRChatApi.Generated.Auth.User.Notifications.NotificationsRequestBuilder(PathParameters, RequestAdapter);
        }
        /// <summary>The playermoderations property</summary>
        public global::VRCZ.VRChatApi.Generated.Auth.User.Playermoderations.PlayermoderationsRequestBuilder Playermoderations
        {
            get => new global::VRCZ.VRChatApi.Generated.Auth.User.Playermoderations.PlayermoderationsRequestBuilder(PathParameters, RequestAdapter);
        }
        /// <summary>The subscription property</summary>
        public global::VRCZ.VRChatApi.Generated.Auth.User.Subscription.SubscriptionRequestBuilder Subscription
        {
            get => new global::VRCZ.VRChatApi.Generated.Auth.User.Subscription.SubscriptionRequestBuilder(PathParameters, RequestAdapter);
        }
        /// <summary>The unplayermoderate property</summary>
        public global::VRCZ.VRChatApi.Generated.Auth.User.Unplayermoderate.UnplayermoderateRequestBuilder Unplayermoderate
        {
            get => new global::VRCZ.VRChatApi.Generated.Auth.User.Unplayermoderate.UnplayermoderateRequestBuilder(PathParameters, RequestAdapter);
        }
        /// <summary>
        /// Instantiates a new <see cref="global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="pathParameters">Path parameters for the request</param>
        /// <param name="requestAdapter">The request adapter to use to execute the requests.</param>
        public UserRequestBuilder(Dictionary<string, object> pathParameters, IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}/auth/user", pathParameters)
        {
        }
        /// <summary>
        /// Instantiates a new <see cref="global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder"/> and sets the default values.
        /// </summary>
        /// <param name="rawUrl">The raw URL to use for the request builder.</param>
        /// <param name="requestAdapter">The request adapter to use to execute the requests.</param>
        public UserRequestBuilder(string rawUrl, IRequestAdapter requestAdapter) : base(requestAdapter, "{+baseurl}/auth/user", rawUrl)
        {
        }
        /// <summary>
        /// This endpoint does the following two operations:  1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.  2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.  &gt; base64(urlencode(username):urlencode(password))**WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
        /// </summary>
        /// <returns>A <see cref="global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse"/></returns>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::VRCZ.VRChatApi.Generated.Models.Error">When receiving a 401 status code</exception>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task<global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse?> GetAsUserGetResponseAsync(Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task<global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse> GetAsUserGetResponseAsync(Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            var requestInfo = ToGetRequestInformation(requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "401", global::VRCZ.VRChatApi.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            return await RequestAdapter.SendAsync<global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse>(requestInfo, global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse.CreateFromDiscriminatorValue, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// This endpoint does the following two operations:  1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.  2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.  &gt; base64(urlencode(username):urlencode(password))**WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
        /// </summary>
        /// <returns>A <see cref="global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse"/></returns>
        /// <param name="cancellationToken">Cancellation token to use when cancelling requests</param>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
        /// <exception cref="global::VRCZ.VRChatApi.Generated.Models.Error">When receiving a 401 status code</exception>
        [Obsolete("This method is obsolete. Use GetAsUserGetResponseAsync instead.")]
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public async Task<global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse?> GetAsync(Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#nullable restore
#else
        public async Task<global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse> GetAsync(Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default, CancellationToken cancellationToken = default)
        {
#endif
            var requestInfo = ToGetRequestInformation(requestConfiguration);
            var errorMapping = new Dictionary<string, ParsableFactory<IParsable>>
            {
                { "401", global::VRCZ.VRChatApi.Generated.Models.Error.CreateFromDiscriminatorValue },
            };
            return await RequestAdapter.SendAsync<global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse>(requestInfo, global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse.CreateFromDiscriminatorValue, errorMapping, cancellationToken).ConfigureAwait(false);
        }
        /// <summary>
        /// This endpoint does the following two operations:  1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.  2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.  &gt; base64(urlencode(username):urlencode(password))**WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
        /// </summary>
        /// <returns>A <see cref="RequestInformation"/></returns>
        /// <param name="requestConfiguration">Configuration for the request such as headers, query parameters, and middleware options.</param>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public RequestInformation ToGetRequestInformation(Action<RequestConfiguration<DefaultQueryParameters>>? requestConfiguration = default)
        {
#nullable restore
#else
        public RequestInformation ToGetRequestInformation(Action<RequestConfiguration<DefaultQueryParameters>> requestConfiguration = default)
        {
#endif
            var requestInfo = new RequestInformation(Method.GET, UrlTemplate, PathParameters);
            requestInfo.Configure(requestConfiguration);
            requestInfo.Headers.TryAdd("Accept", "application/json");
            return requestInfo;
        }
        /// <summary>
        /// Returns a request builder with the provided arbitrary URL. Using this method means any other path or query parameters are ignored.
        /// </summary>
        /// <returns>A <see cref="global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder"/></returns>
        /// <param name="rawUrl">The raw URL to use for the request builder.</param>
        public global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder WithUrl(string rawUrl)
        {
            return new global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder(rawUrl, RequestAdapter);
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::VRCZ.VRChatApi.Generated.Models.CurrentUser"/>, <see cref="global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class UserGetResponse : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::VRCZ.VRChatApi.Generated.Models.CurrentUser"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::VRCZ.VRChatApi.Generated.Models.CurrentUser? CurrentUser { get; set; }
#nullable restore
#else
            public global::VRCZ.VRChatApi.Generated.Models.CurrentUser CurrentUser { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired? TwoFactorRequired { get; set; }
#nullable restore
#else
            public global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired TwoFactorRequired { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                // TODO: Next time when you update the api schema, please modify this method manually
                // The following code will case double deserialization, but we have no choice but to accept it

                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserGetResponse();

                // We just predict user type must have id field
                if (parseNode.GetChildNode("id")?.GetStringValue() is not null)
                {
                    result.CurrentUser = new global::VRCZ.VRChatApi.Generated.Models.CurrentUser();
                }

                // And requiresTwoFactorAuth field
                if (parseNode.GetChildNode("requiresTwoFactorAuth")?.GetCollectionOfEnumValues<global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired_requiresTwoFactorAuth>() is not null)
                {
                    result.TwoFactorRequired = new global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired();
                }

                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CurrentUser != null)
                {
                    return CurrentUser.GetFieldDeserializers();
                }
                else if(TwoFactorRequired != null)
                {
                    return TwoFactorRequired.GetFieldDeserializers();
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(CurrentUser != null)
                {
                    writer.WriteObjectValue<global::VRCZ.VRChatApi.Generated.Models.CurrentUser>(null, CurrentUser);
                }
                else if(TwoFactorRequired != null)
                {
                    writer.WriteObjectValue<global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired>(null, TwoFactorRequired);
                }
            }
        }
        /// <summary>
        /// Configuration for the request such as headers, query parameters, and middleware options.
        /// </summary>
        [Obsolete("This class is deprecated. Please use the generic RequestConfiguration class generated by the generator.")]
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class UserRequestBuilderGetRequestConfiguration : RequestConfiguration<DefaultQueryParameters>
        {
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::VRCZ.VRChatApi.Generated.Models.CurrentUser"/>, <see cref="global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class UserResponse : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::VRCZ.VRChatApi.Generated.Models.CurrentUser"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::VRCZ.VRChatApi.Generated.Models.CurrentUser? CurrentUser { get; set; }
#nullable restore
#else
            public global::VRCZ.VRChatApi.Generated.Models.CurrentUser CurrentUser { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired? TwoFactorRequired { get; set; }
#nullable restore
#else
            public global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired TwoFactorRequired { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var mappingValue = parseNode.GetChildNode("")?.GetStringValue();
                var result = new global::VRCZ.VRChatApi.Generated.Auth.User.UserRequestBuilder.UserResponse();
                if("CurrentUser".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.CurrentUser = new global::VRCZ.VRChatApi.Generated.Models.CurrentUser();
                }
                else if("TwoFactorRequired".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.TwoFactorRequired = new global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CurrentUser != null)
                {
                    return CurrentUser.GetFieldDeserializers();
                }
                else if(TwoFactorRequired != null)
                {
                    return TwoFactorRequired.GetFieldDeserializers();
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(CurrentUser != null)
                {
                    writer.WriteObjectValue<global::VRCZ.VRChatApi.Generated.Models.CurrentUser>(null, CurrentUser);
                }
                else if(TwoFactorRequired != null)
                {
                    writer.WriteObjectValue<global::VRCZ.VRChatApi.Generated.Models.TwoFactorRequired>(null, TwoFactorRequired);
                }
            }
        }
    }
}
#pragma warning restore CS0618
